#
# Autogenerated by Thrift Compiler (1.0.0-dev)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import neteng.fboss.ttypes
import fb303.ttypes
import facebook.network.Address.ttypes
import neteng.fboss.optic.ttypes
import neteng.fboss.highres.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class PortAdminState:
  DISABLED = 0
  ENABLED = 1

  _VALUES_TO_NAMES = {
    0: "DISABLED",
    1: "ENABLED",
  }

  _NAMES_TO_VALUES = {
    "DISABLED": 0,
    "ENABLED": 1,
  }

class PortOperState:
  DOWN = 0
  UP = 1

  _VALUES_TO_NAMES = {
    0: "DOWN",
    1: "UP",
  }

  _NAMES_TO_VALUES = {
    "DOWN": 0,
    "UP": 1,
  }

class BootType:
  UNINITIALIZED = 0
  COLD_BOOT = 1
  WARM_BOOT = 2

  _VALUES_TO_NAMES = {
    0: "UNINITIALIZED",
    1: "COLD_BOOT",
    2: "WARM_BOOT",
  }

  _NAMES_TO_VALUES = {
    "UNINITIALIZED": 0,
    "COLD_BOOT": 1,
    "WARM_BOOT": 2,
  }


class IpPrefix:
  """
  Attributes:
   - ip
   - prefixLength
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ip', (facebook.network.Address.ttypes.BinaryAddress, facebook.network.Address.ttypes.BinaryAddress.thrift_spec), None, ), # 1
    (2, TType.I16, 'prefixLength', None, None, ), # 2
  )

  def __init__(self, ip=None, prefixLength=None,):
    self.ip = ip
    self.prefixLength = prefixLength

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ip = facebook.network.Address.ttypes.BinaryAddress()
          self.ip.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.prefixLength = iprot.readI16()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('IpPrefix')
    if self.ip is not None:
      oprot.writeFieldBegin('ip', TType.STRUCT, 1)
      self.ip.write(oprot)
      oprot.writeFieldEnd()
    if self.prefixLength is not None:
      oprot.writeFieldBegin('prefixLength', TType.I16, 2)
      oprot.writeI16(self.prefixLength)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.ip is None:
      raise TProtocol.TProtocolException(message='Required field ip is unset!')
    if self.prefixLength is None:
      raise TProtocol.TProtocolException(message='Required field prefixLength is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ip)
    value = (value * 31) ^ hash(self.prefixLength)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class UnicastRoute:
  """
  Attributes:
   - dest
   - nextHopAddrs
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'dest', (IpPrefix, IpPrefix.thrift_spec), None, ), # 1
    (2, TType.LIST, 'nextHopAddrs', (TType.STRUCT,(facebook.network.Address.ttypes.BinaryAddress, facebook.network.Address.ttypes.BinaryAddress.thrift_spec)), None, ), # 2
  )

  def __init__(self, dest=None, nextHopAddrs=None,):
    self.dest = dest
    self.nextHopAddrs = nextHopAddrs

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.dest = IpPrefix()
          self.dest.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.nextHopAddrs = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = facebook.network.Address.ttypes.BinaryAddress()
            _elem5.read(iprot)
            self.nextHopAddrs.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnicastRoute')
    if self.dest is not None:
      oprot.writeFieldBegin('dest', TType.STRUCT, 1)
      self.dest.write(oprot)
      oprot.writeFieldEnd()
    if self.nextHopAddrs is not None:
      oprot.writeFieldBegin('nextHopAddrs', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.nextHopAddrs))
      for iter6 in self.nextHopAddrs:
        iter6.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dest is None:
      raise TProtocol.TProtocolException(message='Required field dest is unset!')
    if self.nextHopAddrs is None:
      raise TProtocol.TProtocolException(message='Required field nextHopAddrs is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dest)
    value = (value * 31) ^ hash(self.nextHopAddrs)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ArpEntryThrift:
  """
  Attributes:
   - mac
   - port
   - vlanName
   - ip
   - vlanID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'mac', None, None, ), # 1
    (2, TType.I32, 'port', None, None, ), # 2
    (3, TType.STRING, 'vlanName', None, None, ), # 3
    (4, TType.STRUCT, 'ip', (facebook.network.Address.ttypes.BinaryAddress, facebook.network.Address.ttypes.BinaryAddress.thrift_spec), None, ), # 4
    (5, TType.I32, 'vlanID', None, None, ), # 5
  )

  def __init__(self, mac=None, port=None, vlanName=None, ip=None, vlanID=None,):
    self.mac = mac
    self.port = port
    self.vlanName = vlanName
    self.ip = ip
    self.vlanID = vlanID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.mac = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.vlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.ip = facebook.network.Address.ttypes.BinaryAddress()
          self.ip.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.vlanID = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ArpEntryThrift')
    if self.mac is not None:
      oprot.writeFieldBegin('mac', TType.STRING, 1)
      oprot.writeString(self.mac)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 2)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.vlanName is not None:
      oprot.writeFieldBegin('vlanName', TType.STRING, 3)
      oprot.writeString(self.vlanName)
      oprot.writeFieldEnd()
    if self.ip is not None:
      oprot.writeFieldBegin('ip', TType.STRUCT, 4)
      self.ip.write(oprot)
      oprot.writeFieldEnd()
    if self.vlanID is not None:
      oprot.writeFieldBegin('vlanID', TType.I32, 5)
      oprot.writeI32(self.vlanID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mac)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.vlanName)
    value = (value * 31) ^ hash(self.ip)
    value = (value * 31) ^ hash(self.vlanID)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InterfaceDetail:
  """
  Attributes:
   - interfaceName
   - interfaceId
   - vlanId
   - routerId
   - mac
   - address
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'interfaceName', None, None, ), # 1
    (2, TType.I32, 'interfaceId', None, None, ), # 2
    (3, TType.I32, 'vlanId', None, None, ), # 3
    (4, TType.I32, 'routerId', None, None, ), # 4
    (5, TType.STRING, 'mac', None, None, ), # 5
    (6, TType.LIST, 'address', (TType.STRUCT,(IpPrefix, IpPrefix.thrift_spec)), None, ), # 6
  )

  def __init__(self, interfaceName=None, interfaceId=None, vlanId=None, routerId=None, mac=None, address=None,):
    self.interfaceName = interfaceName
    self.interfaceId = interfaceId
    self.vlanId = vlanId
    self.routerId = routerId
    self.mac = mac
    self.address = address

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.interfaceName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.interfaceId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.vlanId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.routerId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.mac = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.LIST:
          self.address = []
          (_etype10, _size7) = iprot.readListBegin()
          for _i11 in xrange(_size7):
            _elem12 = IpPrefix()
            _elem12.read(iprot)
            self.address.append(_elem12)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InterfaceDetail')
    if self.interfaceName is not None:
      oprot.writeFieldBegin('interfaceName', TType.STRING, 1)
      oprot.writeString(self.interfaceName)
      oprot.writeFieldEnd()
    if self.interfaceId is not None:
      oprot.writeFieldBegin('interfaceId', TType.I32, 2)
      oprot.writeI32(self.interfaceId)
      oprot.writeFieldEnd()
    if self.vlanId is not None:
      oprot.writeFieldBegin('vlanId', TType.I32, 3)
      oprot.writeI32(self.vlanId)
      oprot.writeFieldEnd()
    if self.routerId is not None:
      oprot.writeFieldBegin('routerId', TType.I32, 4)
      oprot.writeI32(self.routerId)
      oprot.writeFieldEnd()
    if self.mac is not None:
      oprot.writeFieldBegin('mac', TType.STRING, 5)
      oprot.writeString(self.mac)
      oprot.writeFieldEnd()
    if self.address is not None:
      oprot.writeFieldBegin('address', TType.LIST, 6)
      oprot.writeListBegin(TType.STRUCT, len(self.address))
      for iter13 in self.address:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.interfaceName)
    value = (value * 31) ^ hash(self.interfaceId)
    value = (value * 31) ^ hash(self.vlanId)
    value = (value * 31) ^ hash(self.routerId)
    value = (value * 31) ^ hash(self.mac)
    value = (value * 31) ^ hash(self.address)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class ProductInfo:
  """
  Attributes:
   - oem
   - product
   - serial
   - macRangeStart
   - macRangeSize
   - mfgDate
   - systemPartNumber
   - assembledAt
   - pcbManufacturer
   - assetTag
   - partNumber
   - odmPcbPartNumber
   - odmPcbSerial
   - fbPcbPartNumber
   - version
   - subVersion
   - productionState
   - productVersion
   - bmcMac
   - mgmtMac
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'oem', None, None, ), # 1
    (2, TType.STRING, 'product', None, None, ), # 2
    (3, TType.STRING, 'serial', None, None, ), # 3
    (4, TType.STRING, 'macRangeStart', None, None, ), # 4
    (5, TType.I16, 'macRangeSize', None, None, ), # 5
    (6, TType.STRING, 'mfgDate', None, None, ), # 6
    (7, TType.STRING, 'systemPartNumber', None, None, ), # 7
    (8, TType.STRING, 'assembledAt', None, None, ), # 8
    (9, TType.STRING, 'pcbManufacturer', None, None, ), # 9
    (10, TType.STRING, 'assetTag', None, None, ), # 10
    (11, TType.STRING, 'partNumber', None, None, ), # 11
    (12, TType.STRING, 'odmPcbPartNumber', None, None, ), # 12
    (13, TType.STRING, 'odmPcbSerial', None, None, ), # 13
    (14, TType.STRING, 'fbPcbPartNumber', None, None, ), # 14
    (15, TType.I16, 'version', None, None, ), # 15
    (16, TType.I16, 'subVersion', None, None, ), # 16
    (17, TType.I16, 'productionState', None, None, ), # 17
    (18, TType.I16, 'productVersion', None, None, ), # 18
    (19, TType.STRING, 'bmcMac', None, None, ), # 19
    (20, TType.STRING, 'mgmtMac', None, None, ), # 20
  )

  def __init__(self, oem=None, product=None, serial=None, macRangeStart=None, macRangeSize=None, mfgDate=None, systemPartNumber=None, assembledAt=None, pcbManufacturer=None, assetTag=None, partNumber=None, odmPcbPartNumber=None, odmPcbSerial=None, fbPcbPartNumber=None, version=None, subVersion=None, productionState=None, productVersion=None, bmcMac=None, mgmtMac=None,):
    self.oem = oem
    self.product = product
    self.serial = serial
    self.macRangeStart = macRangeStart
    self.macRangeSize = macRangeSize
    self.mfgDate = mfgDate
    self.systemPartNumber = systemPartNumber
    self.assembledAt = assembledAt
    self.pcbManufacturer = pcbManufacturer
    self.assetTag = assetTag
    self.partNumber = partNumber
    self.odmPcbPartNumber = odmPcbPartNumber
    self.odmPcbSerial = odmPcbSerial
    self.fbPcbPartNumber = fbPcbPartNumber
    self.version = version
    self.subVersion = subVersion
    self.productionState = productionState
    self.productVersion = productVersion
    self.bmcMac = bmcMac
    self.mgmtMac = mgmtMac

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.oem = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.product = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.serial = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.macRangeStart = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.macRangeSize = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.mfgDate = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.systemPartNumber = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.assembledAt = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.pcbManufacturer = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.assetTag = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.partNumber = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.odmPcbPartNumber = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.odmPcbSerial = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.fbPcbPartNumber = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I16:
          self.version = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.I16:
          self.subVersion = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I16:
          self.productionState = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.I16:
          self.productVersion = iprot.readI16()
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRING:
          self.bmcMac = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRING:
          self.mgmtMac = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('ProductInfo')
    if self.oem is not None:
      oprot.writeFieldBegin('oem', TType.STRING, 1)
      oprot.writeString(self.oem)
      oprot.writeFieldEnd()
    if self.product is not None:
      oprot.writeFieldBegin('product', TType.STRING, 2)
      oprot.writeString(self.product)
      oprot.writeFieldEnd()
    if self.serial is not None:
      oprot.writeFieldBegin('serial', TType.STRING, 3)
      oprot.writeString(self.serial)
      oprot.writeFieldEnd()
    if self.macRangeStart is not None:
      oprot.writeFieldBegin('macRangeStart', TType.STRING, 4)
      oprot.writeString(self.macRangeStart)
      oprot.writeFieldEnd()
    if self.macRangeSize is not None:
      oprot.writeFieldBegin('macRangeSize', TType.I16, 5)
      oprot.writeI16(self.macRangeSize)
      oprot.writeFieldEnd()
    if self.mfgDate is not None:
      oprot.writeFieldBegin('mfgDate', TType.STRING, 6)
      oprot.writeString(self.mfgDate)
      oprot.writeFieldEnd()
    if self.systemPartNumber is not None:
      oprot.writeFieldBegin('systemPartNumber', TType.STRING, 7)
      oprot.writeString(self.systemPartNumber)
      oprot.writeFieldEnd()
    if self.assembledAt is not None:
      oprot.writeFieldBegin('assembledAt', TType.STRING, 8)
      oprot.writeString(self.assembledAt)
      oprot.writeFieldEnd()
    if self.pcbManufacturer is not None:
      oprot.writeFieldBegin('pcbManufacturer', TType.STRING, 9)
      oprot.writeString(self.pcbManufacturer)
      oprot.writeFieldEnd()
    if self.assetTag is not None:
      oprot.writeFieldBegin('assetTag', TType.STRING, 10)
      oprot.writeString(self.assetTag)
      oprot.writeFieldEnd()
    if self.partNumber is not None:
      oprot.writeFieldBegin('partNumber', TType.STRING, 11)
      oprot.writeString(self.partNumber)
      oprot.writeFieldEnd()
    if self.odmPcbPartNumber is not None:
      oprot.writeFieldBegin('odmPcbPartNumber', TType.STRING, 12)
      oprot.writeString(self.odmPcbPartNumber)
      oprot.writeFieldEnd()
    if self.odmPcbSerial is not None:
      oprot.writeFieldBegin('odmPcbSerial', TType.STRING, 13)
      oprot.writeString(self.odmPcbSerial)
      oprot.writeFieldEnd()
    if self.fbPcbPartNumber is not None:
      oprot.writeFieldBegin('fbPcbPartNumber', TType.STRING, 14)
      oprot.writeString(self.fbPcbPartNumber)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.I16, 15)
      oprot.writeI16(self.version)
      oprot.writeFieldEnd()
    if self.subVersion is not None:
      oprot.writeFieldBegin('subVersion', TType.I16, 16)
      oprot.writeI16(self.subVersion)
      oprot.writeFieldEnd()
    if self.productionState is not None:
      oprot.writeFieldBegin('productionState', TType.I16, 17)
      oprot.writeI16(self.productionState)
      oprot.writeFieldEnd()
    if self.productVersion is not None:
      oprot.writeFieldBegin('productVersion', TType.I16, 18)
      oprot.writeI16(self.productVersion)
      oprot.writeFieldEnd()
    if self.bmcMac is not None:
      oprot.writeFieldBegin('bmcMac', TType.STRING, 19)
      oprot.writeString(self.bmcMac)
      oprot.writeFieldEnd()
    if self.mgmtMac is not None:
      oprot.writeFieldBegin('mgmtMac', TType.STRING, 20)
      oprot.writeString(self.mgmtMac)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.oem)
    value = (value * 31) ^ hash(self.product)
    value = (value * 31) ^ hash(self.serial)
    value = (value * 31) ^ hash(self.macRangeStart)
    value = (value * 31) ^ hash(self.macRangeSize)
    value = (value * 31) ^ hash(self.mfgDate)
    value = (value * 31) ^ hash(self.systemPartNumber)
    value = (value * 31) ^ hash(self.assembledAt)
    value = (value * 31) ^ hash(self.pcbManufacturer)
    value = (value * 31) ^ hash(self.assetTag)
    value = (value * 31) ^ hash(self.partNumber)
    value = (value * 31) ^ hash(self.odmPcbPartNumber)
    value = (value * 31) ^ hash(self.odmPcbSerial)
    value = (value * 31) ^ hash(self.fbPcbPartNumber)
    value = (value * 31) ^ hash(self.version)
    value = (value * 31) ^ hash(self.subVersion)
    value = (value * 31) ^ hash(self.productionState)
    value = (value * 31) ^ hash(self.productVersion)
    value = (value * 31) ^ hash(self.bmcMac)
    value = (value * 31) ^ hash(self.mgmtMac)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PortErrors:
  """
  Attributes:
   - errors
   - discards
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'errors', None, None, ), # 1
    (2, TType.I64, 'discards', None, None, ), # 2
  )

  def __init__(self, errors=None, discards=None,):
    self.errors = errors
    self.discards = discards

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.errors = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.discards = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PortErrors')
    if self.errors is not None:
      oprot.writeFieldBegin('errors', TType.I64, 1)
      oprot.writeI64(self.errors)
      oprot.writeFieldEnd()
    if self.discards is not None:
      oprot.writeFieldBegin('discards', TType.I64, 2)
      oprot.writeI64(self.discards)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.errors)
    value = (value * 31) ^ hash(self.discards)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PortCounters:
  """
  Attributes:
   - bytes
   - ucastPkts
   - multicastPkts
   - broadcastPkts
   - errors
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'bytes', None, None, ), # 1
    (2, TType.I64, 'ucastPkts', None, None, ), # 2
    (3, TType.I64, 'multicastPkts', None, None, ), # 3
    (4, TType.I64, 'broadcastPkts', None, None, ), # 4
    (5, TType.STRUCT, 'errors', (PortErrors, PortErrors.thrift_spec), None, ), # 5
  )

  def __init__(self, bytes=None, ucastPkts=None, multicastPkts=None, broadcastPkts=None, errors=None,):
    self.bytes = bytes
    self.ucastPkts = ucastPkts
    self.multicastPkts = multicastPkts
    self.broadcastPkts = broadcastPkts
    self.errors = errors

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.bytes = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.ucastPkts = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.multicastPkts = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.broadcastPkts = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.errors = PortErrors()
          self.errors.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PortCounters')
    if self.bytes is not None:
      oprot.writeFieldBegin('bytes', TType.I64, 1)
      oprot.writeI64(self.bytes)
      oprot.writeFieldEnd()
    if self.ucastPkts is not None:
      oprot.writeFieldBegin('ucastPkts', TType.I64, 2)
      oprot.writeI64(self.ucastPkts)
      oprot.writeFieldEnd()
    if self.multicastPkts is not None:
      oprot.writeFieldBegin('multicastPkts', TType.I64, 3)
      oprot.writeI64(self.multicastPkts)
      oprot.writeFieldEnd()
    if self.broadcastPkts is not None:
      oprot.writeFieldBegin('broadcastPkts', TType.I64, 4)
      oprot.writeI64(self.broadcastPkts)
      oprot.writeFieldEnd()
    if self.errors is not None:
      oprot.writeFieldBegin('errors', TType.STRUCT, 5)
      self.errors.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.bytes)
    value = (value * 31) ^ hash(self.ucastPkts)
    value = (value * 31) ^ hash(self.multicastPkts)
    value = (value * 31) ^ hash(self.broadcastPkts)
    value = (value * 31) ^ hash(self.errors)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PortStatThrift:
  """
  Attributes:
   - portId
   - speedMbps
   - adminState
   - operState
   - output
   - input
   - name
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'portId', None, None, ), # 1
    (2, TType.I64, 'speedMbps', None, None, ), # 2
    (3, TType.I32, 'adminState', None, None, ), # 3
    (4, TType.I32, 'operState', None, None, ), # 4
    None, # 5
    None, # 6
    None, # 7
    None, # 8
    None, # 9
    (10, TType.STRUCT, 'output', (PortCounters, PortCounters.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'input', (PortCounters, PortCounters.thrift_spec), None, ), # 11
    (12, TType.STRING, 'name', None, None, ), # 12
  )

  def __init__(self, portId=None, speedMbps=None, adminState=None, operState=None, output=None, input=None, name=None,):
    self.portId = portId
    self.speedMbps = speedMbps
    self.adminState = adminState
    self.operState = operState
    self.output = output
    self.input = input
    self.name = name

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.portId = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.speedMbps = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.adminState = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.operState = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.output = PortCounters()
          self.output.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.input = PortCounters()
          self.input.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PortStatThrift')
    if self.portId is not None:
      oprot.writeFieldBegin('portId', TType.I32, 1)
      oprot.writeI32(self.portId)
      oprot.writeFieldEnd()
    if self.speedMbps is not None:
      oprot.writeFieldBegin('speedMbps', TType.I64, 2)
      oprot.writeI64(self.speedMbps)
      oprot.writeFieldEnd()
    if self.adminState is not None:
      oprot.writeFieldBegin('adminState', TType.I32, 3)
      oprot.writeI32(self.adminState)
      oprot.writeFieldEnd()
    if self.operState is not None:
      oprot.writeFieldBegin('operState', TType.I32, 4)
      oprot.writeI32(self.operState)
      oprot.writeFieldEnd()
    if self.output is not None:
      oprot.writeFieldBegin('output', TType.STRUCT, 10)
      self.output.write(oprot)
      oprot.writeFieldEnd()
    if self.input is not None:
      oprot.writeFieldBegin('input', TType.STRUCT, 11)
      self.input.write(oprot)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 12)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.portId)
    value = (value * 31) ^ hash(self.speedMbps)
    value = (value * 31) ^ hash(self.adminState)
    value = (value * 31) ^ hash(self.operState)
    value = (value * 31) ^ hash(self.output)
    value = (value * 31) ^ hash(self.input)
    value = (value * 31) ^ hash(self.name)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class NdpEntryThrift:
  """
  Attributes:
   - ip
   - mac
   - port
   - vlanName
   - vlanID
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'ip', (facebook.network.Address.ttypes.BinaryAddress, facebook.network.Address.ttypes.BinaryAddress.thrift_spec), None, ), # 1
    (2, TType.STRING, 'mac', None, None, ), # 2
    (3, TType.I32, 'port', None, None, ), # 3
    (4, TType.STRING, 'vlanName', None, None, ), # 4
    (5, TType.I32, 'vlanID', None, None, ), # 5
  )

  def __init__(self, ip=None, mac=None, port=None, vlanName=None, vlanID=None,):
    self.ip = ip
    self.mac = mac
    self.port = port
    self.vlanName = vlanName
    self.vlanID = vlanID

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.ip = facebook.network.Address.ttypes.BinaryAddress()
          self.ip.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.mac = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.port = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRING:
          self.vlanName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.vlanID = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('NdpEntryThrift')
    if self.ip is not None:
      oprot.writeFieldBegin('ip', TType.STRUCT, 1)
      self.ip.write(oprot)
      oprot.writeFieldEnd()
    if self.mac is not None:
      oprot.writeFieldBegin('mac', TType.STRING, 2)
      oprot.writeString(self.mac)
      oprot.writeFieldEnd()
    if self.port is not None:
      oprot.writeFieldBegin('port', TType.I32, 3)
      oprot.writeI32(self.port)
      oprot.writeFieldEnd()
    if self.vlanName is not None:
      oprot.writeFieldBegin('vlanName', TType.STRING, 4)
      oprot.writeString(self.vlanName)
      oprot.writeFieldEnd()
    if self.vlanID is not None:
      oprot.writeFieldBegin('vlanID', TType.I32, 5)
      oprot.writeI32(self.vlanID)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.ip)
    value = (value * 31) ^ hash(self.mac)
    value = (value * 31) ^ hash(self.port)
    value = (value * 31) ^ hash(self.vlanName)
    value = (value * 31) ^ hash(self.vlanID)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PortStatus:
  """
  Attributes:
   - enabled
   - up
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'enabled', None, None, ), # 1
    (2, TType.BOOL, 'up', None, None, ), # 2
  )

  def __init__(self, enabled=None, up=None,):
    self.enabled = enabled
    self.up = up

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.enabled = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.up = iprot.readBool()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PortStatus')
    if self.enabled is not None:
      oprot.writeFieldBegin('enabled', TType.BOOL, 1)
      oprot.writeBool(self.enabled)
      oprot.writeFieldEnd()
    if self.up is not None:
      oprot.writeFieldBegin('up', TType.BOOL, 2)
      oprot.writeBool(self.up)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.enabled)
    value = (value * 31) ^ hash(self.up)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class CaptureInfo:
  """
  Attributes:
   - name
   - maxPackets
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I32, 'maxPackets', None, None, ), # 2
  )

  def __init__(self, name=None, maxPackets=None,):
    self.name = name
    self.maxPackets = maxPackets

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.maxPackets = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('CaptureInfo')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.maxPackets is not None:
      oprot.writeFieldBegin('maxPackets', TType.I32, 2)
      oprot.writeI32(self.maxPackets)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.maxPackets)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class LinkNeighborThrift:
  """
  Attributes:
   - localPort
   - localVlan
   - chassisIdType
   - portIdType
   - originalTTL
   - ttlSecondsLeft
   - srcMac
   - chassisId
   - printableChassisId
   - portId
   - printablePortId
   - systemName
   - systemDescription
   - portDescription
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'localPort', None, None, ), # 1
    (2, TType.I32, 'localVlan', None, None, ), # 2
    (3, TType.I32, 'chassisIdType', None, None, ), # 3
    (4, TType.I32, 'portIdType', None, None, ), # 4
    (5, TType.I32, 'originalTTL', None, None, ), # 5
    (6, TType.I32, 'ttlSecondsLeft', None, None, ), # 6
    (7, TType.STRING, 'srcMac', None, None, ), # 7
    (8, TType.STRING, 'chassisId', None, None, ), # 8
    (9, TType.STRING, 'printableChassisId', None, None, ), # 9
    (10, TType.STRING, 'portId', None, None, ), # 10
    (11, TType.STRING, 'printablePortId', None, None, ), # 11
    (12, TType.STRING, 'systemName', None, None, ), # 12
    (13, TType.STRING, 'systemDescription', None, None, ), # 13
    (14, TType.STRING, 'portDescription', None, None, ), # 14
  )

  def __init__(self, localPort=None, localVlan=None, chassisIdType=None, portIdType=None, originalTTL=None, ttlSecondsLeft=None, srcMac=None, chassisId=None, printableChassisId=None, portId=None, printablePortId=None, systemName=None, systemDescription=None, portDescription=None,):
    self.localPort = localPort
    self.localVlan = localVlan
    self.chassisIdType = chassisIdType
    self.portIdType = portIdType
    self.originalTTL = originalTTL
    self.ttlSecondsLeft = ttlSecondsLeft
    self.srcMac = srcMac
    self.chassisId = chassisId
    self.printableChassisId = printableChassisId
    self.portId = portId
    self.printablePortId = printablePortId
    self.systemName = systemName
    self.systemDescription = systemDescription
    self.portDescription = portDescription

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.localPort = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.localVlan = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.chassisIdType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.portIdType = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.originalTTL = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.ttlSecondsLeft = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.srcMac = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.chassisId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRING:
          self.printableChassisId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRING:
          self.portId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRING:
          self.printablePortId = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRING:
          self.systemName = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRING:
          self.systemDescription = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRING:
          self.portDescription = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('LinkNeighborThrift')
    if self.localPort is not None:
      oprot.writeFieldBegin('localPort', TType.I32, 1)
      oprot.writeI32(self.localPort)
      oprot.writeFieldEnd()
    if self.localVlan is not None:
      oprot.writeFieldBegin('localVlan', TType.I32, 2)
      oprot.writeI32(self.localVlan)
      oprot.writeFieldEnd()
    if self.chassisIdType is not None:
      oprot.writeFieldBegin('chassisIdType', TType.I32, 3)
      oprot.writeI32(self.chassisIdType)
      oprot.writeFieldEnd()
    if self.portIdType is not None:
      oprot.writeFieldBegin('portIdType', TType.I32, 4)
      oprot.writeI32(self.portIdType)
      oprot.writeFieldEnd()
    if self.originalTTL is not None:
      oprot.writeFieldBegin('originalTTL', TType.I32, 5)
      oprot.writeI32(self.originalTTL)
      oprot.writeFieldEnd()
    if self.ttlSecondsLeft is not None:
      oprot.writeFieldBegin('ttlSecondsLeft', TType.I32, 6)
      oprot.writeI32(self.ttlSecondsLeft)
      oprot.writeFieldEnd()
    if self.srcMac is not None:
      oprot.writeFieldBegin('srcMac', TType.STRING, 7)
      oprot.writeString(self.srcMac)
      oprot.writeFieldEnd()
    if self.chassisId is not None:
      oprot.writeFieldBegin('chassisId', TType.STRING, 8)
      oprot.writeString(self.chassisId)
      oprot.writeFieldEnd()
    if self.printableChassisId is not None:
      oprot.writeFieldBegin('printableChassisId', TType.STRING, 9)
      oprot.writeString(self.printableChassisId)
      oprot.writeFieldEnd()
    if self.portId is not None:
      oprot.writeFieldBegin('portId', TType.STRING, 10)
      oprot.writeString(self.portId)
      oprot.writeFieldEnd()
    if self.printablePortId is not None:
      oprot.writeFieldBegin('printablePortId', TType.STRING, 11)
      oprot.writeString(self.printablePortId)
      oprot.writeFieldEnd()
    if self.systemName is not None:
      oprot.writeFieldBegin('systemName', TType.STRING, 12)
      oprot.writeString(self.systemName)
      oprot.writeFieldEnd()
    if self.systemDescription is not None:
      oprot.writeFieldBegin('systemDescription', TType.STRING, 13)
      oprot.writeString(self.systemDescription)
      oprot.writeFieldEnd()
    if self.portDescription is not None:
      oprot.writeFieldBegin('portDescription', TType.STRING, 14)
      oprot.writeString(self.portDescription)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.localPort)
    value = (value * 31) ^ hash(self.localVlan)
    value = (value * 31) ^ hash(self.chassisIdType)
    value = (value * 31) ^ hash(self.portIdType)
    value = (value * 31) ^ hash(self.originalTTL)
    value = (value * 31) ^ hash(self.ttlSecondsLeft)
    value = (value * 31) ^ hash(self.srcMac)
    value = (value * 31) ^ hash(self.chassisId)
    value = (value * 31) ^ hash(self.printableChassisId)
    value = (value * 31) ^ hash(self.portId)
    value = (value * 31) ^ hash(self.printablePortId)
    value = (value * 31) ^ hash(self.systemName)
    value = (value * 31) ^ hash(self.systemDescription)
    value = (value * 31) ^ hash(self.portDescription)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
